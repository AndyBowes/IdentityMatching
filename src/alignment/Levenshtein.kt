package alignment

/**
 * Created by Sam & Andy on 27/04/2016.
 */
    fun charScore(char1 : Char, char2: Char): Int{
        return if (char1 == char2) 0 else 1
    }


    enum class Direction(dx : Int, dy: Int) {
        HOME(0,0), RIGHT(1,0), DOWN(0,1), DIAGONAL(1,1)
    }
    data class MatrixElement(val score: Int, val direction : Direction)


    /**
     * Backtrack through a scoring matrix to identify the alignments which generate the best possible score
     *
     * @param seq1 The 1st original sequence
     * @param seq2 The 2nd original sequence
     * @param matrix The scoring matrix which was generated by the Levenshtein algorithm
     *
     * @return An instance of {@link Pair<String,String>} which contains the alignments with the inserted gaps
     *
     */
    fun backTrack(seq1: String, seq2: String, matrix: List<List<MatrixElement>>): Pair<String,String> {
        var x = matrix[0].size - 1
        var y = matrix.size - 1
        var align1 = StringBuffer()
        var align2 = StringBuffer()
        while (matrix[y][x].direction != Direction.HOME) {
            val direction :Direction = matrix[y][x].direction
            when (direction) {
                Direction.RIGHT -> {
                     x -= 1
                    align1.append(seq1.get(x))
                    align2.append('-')
                }
                Direction.DOWN -> {
                    y -= 1
                    align1.append('-')
                    align2.append(seq2.get(y))
                }
                Direction.DIAGONAL -> {
                    x -= 1
                    y -= 1
                    align1.append(seq1.get(x))
                    align2.append(seq2.get(y))
                }
            }
        }
        return Pair(align1.reverse()!!.toString(), align2.reverse()!!.toString())
    }

    fun levenshtein(s: String, s1: String): Triple<Int, String, String> {
        val rows : MutableList<List<MatrixElement>> = arrayListOf()
        var previousRow : MutableList<MatrixElement> = arrayListOf()
        previousRow.add(MatrixElement(0, Direction.HOME))
        for (i in 1 .. s.length){ previousRow.add(MatrixElement(i, Direction.RIGHT))} // Top Row
        rows.add(previousRow)
        for (i in 1..s1.length) {
            var nextRow : MutableList<MatrixElement> = arrayListOf() // Initialise Next Row
            nextRow.add(MatrixElement(previousRow[0].score + 1, Direction.DOWN)) // First element of new row = Move Down from previous row + 1
            for (j in 1..s.length) {
                val minValue  = arrayOf(MatrixElement(previousRow[j].score + 1, Direction.DOWN),          // Move Down
                                     MatrixElement(nextRow[j - 1].score + 1, Direction.RIGHT),    // Move Right
                                     MatrixElement(previousRow[j - 1].score + charScore(s[j - 1], s1[i - 1]), Direction.DIAGONAL)) // Diagonal
                                        .minBy({it.score})// Find minimum value of the 3 available moves
                nextRow.add(minValue!!)
            }
            previousRow = nextRow
            rows.add(previousRow)
        }
        // Return last value from final row
        val alignments = backTrack(s, s1, rows)
        return Triple(rows[s1.length][s.length].score, alignments.first, alignments.second)
    }
